#[doc = "Local Capture High Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct CaptureH(pub u32);
impl CaptureH {
    #[doc = "A read reflects the value of the upper 32 bits of the central EVTIMER at the time the last capture signal was generated by the CPU. A separate pair of CAPTURE registers are implemented for each CPU. Each CPU reads its own capture value at the same pair of addresses."]
    #[must_use]
    #[inline(always)]
    pub const fn capture_value(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0xffff_ffff;
        val as u32
    }
    #[doc = "A read reflects the value of the upper 32 bits of the central EVTIMER at the time the last capture signal was generated by the CPU. A separate pair of CAPTURE registers are implemented for each CPU. Each CPU reads its own capture value at the same pair of addresses."]
    #[inline(always)]
    pub const fn set_capture_value(&mut self, val: u32) {
        self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
    }
}
impl Default for CaptureH {
    #[inline(always)]
    fn default() -> CaptureH {
        CaptureH(0)
    }
}
impl core::fmt::Debug for CaptureH {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CaptureH")
            .field("capture_value", &self.capture_value())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for CaptureH {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "CaptureH {{ capture_value: {=u32:?} }}",
            self.capture_value()
        )
    }
}
#[doc = "Local Capture Low Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct CaptureL(pub u32);
impl CaptureL {
    #[doc = "A read reflects the value of the lower 32 bits of the central EVTIMER at the time the last capture signal was generated by the CPU. A separate pair of CAPTURE registers are implemented for each CPU. Each CPU reads its own capture value at the same pair of addresses."]
    #[must_use]
    #[inline(always)]
    pub const fn capture_value(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0xffff_ffff;
        val as u32
    }
    #[doc = "A read reflects the value of the lower 32 bits of the central EVTIMER at the time the last capture signal was generated by the CPU. A separate pair of CAPTURE registers are implemented for each CPU. Each CPU reads its own capture value at the same pair of addresses."]
    #[inline(always)]
    pub const fn set_capture_value(&mut self, val: u32) {
        self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
    }
}
impl Default for CaptureL {
    #[inline(always)]
    fn default() -> CaptureL {
        CaptureL(0)
    }
}
impl core::fmt::Debug for CaptureL {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CaptureL")
            .field("capture_value", &self.capture_value())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for CaptureL {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "CaptureL {{ capture_value: {=u32:?} }}",
            self.capture_value()
        )
    }
}
#[doc = "EVTIMER High Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Evtimerh(pub u32);
impl Evtimerh {
    #[doc = "A read reflects the current value of the upper 32 bits of the EVTIMER. Note there is physically only one EVTimer, readable from all domains."]
    #[must_use]
    #[inline(always)]
    pub const fn evtimer_count_value(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0xffff_ffff;
        val as u32
    }
    #[doc = "A read reflects the current value of the upper 32 bits of the EVTIMER. Note there is physically only one EVTimer, readable from all domains."]
    #[inline(always)]
    pub const fn set_evtimer_count_value(&mut self, val: u32) {
        self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
    }
}
impl Default for Evtimerh {
    #[inline(always)]
    fn default() -> Evtimerh {
        Evtimerh(0)
    }
}
impl core::fmt::Debug for Evtimerh {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Evtimerh")
            .field("evtimer_count_value", &self.evtimer_count_value())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Evtimerh {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Evtimerh {{ evtimer_count_value: {=u32:?} }}",
            self.evtimer_count_value()
        )
    }
}
#[doc = "EVTIMER Low Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Evtimerl(pub u32);
impl Evtimerl {
    #[doc = "A read reflects the current value of the lower 32 bits of the EVTIMER. Note there is physically only one EVTimer, readable from all domains."]
    #[must_use]
    #[inline(always)]
    pub const fn evtimer_count_value(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0xffff_ffff;
        val as u32
    }
    #[doc = "A read reflects the current value of the lower 32 bits of the EVTIMER. Note there is physically only one EVTimer, readable from all domains."]
    #[inline(always)]
    pub const fn set_evtimer_count_value(&mut self, val: u32) {
        self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
    }
}
impl Default for Evtimerl {
    #[inline(always)]
    fn default() -> Evtimerl {
        Evtimerl(0)
    }
}
impl core::fmt::Debug for Evtimerl {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Evtimerl")
            .field("evtimer_count_value", &self.evtimer_count_value())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for Evtimerl {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "Evtimerl {{ evtimer_count_value: {=u32:?} }}",
            self.evtimer_count_value()
        )
    }
}
#[doc = "Match High Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MatchH(pub u32);
impl MatchH {
    #[doc = "The value written to the MATCH (L/H) register pair is compared against the central EVTIMER. When a match occurs, an interrupt request is generated if enabled. A separate pair of MATCH registers are implemented for each CPU. Each CPU reads its own local value at the same pair of addresses."]
    #[must_use]
    #[inline(always)]
    pub const fn match_value(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0xffff_ffff;
        val as u32
    }
    #[doc = "The value written to the MATCH (L/H) register pair is compared against the central EVTIMER. When a match occurs, an interrupt request is generated if enabled. A separate pair of MATCH registers are implemented for each CPU. Each CPU reads its own local value at the same pair of addresses."]
    #[inline(always)]
    pub const fn set_match_value(&mut self, val: u32) {
        self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
    }
}
impl Default for MatchH {
    #[inline(always)]
    fn default() -> MatchH {
        MatchH(0)
    }
}
impl core::fmt::Debug for MatchH {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MatchH")
            .field("match_value", &self.match_value())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for MatchH {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(f, "MatchH {{ match_value: {=u32:?} }}", self.match_value())
    }
}
#[doc = "Local Match Low Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MatchL(pub u32);
impl MatchL {
    #[doc = "The value written to the MATCH (L/H) register pair is compared against the central EVTIMER. When a match occurs, an interrupt request is generated if enabled. A separate pair of MATCH registers are implemented for each CPU. Each CPU reads its own local value at the same pair of addresses."]
    #[must_use]
    #[inline(always)]
    pub const fn match_value(&self) -> u32 {
        let val = (self.0 >> 0usize) & 0xffff_ffff;
        val as u32
    }
    #[doc = "The value written to the MATCH (L/H) register pair is compared against the central EVTIMER. When a match occurs, an interrupt request is generated if enabled. A separate pair of MATCH registers are implemented for each CPU. Each CPU reads its own local value at the same pair of addresses."]
    #[inline(always)]
    pub const fn set_match_value(&mut self, val: u32) {
        self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
    }
}
impl Default for MatchL {
    #[inline(always)]
    fn default() -> MatchL {
        MatchL(0)
    }
}
impl core::fmt::Debug for MatchL {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("MatchL")
            .field("match_value", &self.match_value())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for MatchL {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(f, "MatchL {{ match_value: {=u32:?} }}", self.match_value())
    }
}
#[doc = "OS_EVENT TIMER Control Register"]
#[repr(transparent)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct OseventCtrl(pub u32);
impl OseventCtrl {
    #[doc = "This bit is set when a match occurs between the central 64-bit EVTIMER and the value programmed in the Match-register pair for the associated CPU This bit is cleared by writing a '1'. Writes to clear this bit are asynchronous. This should be done before a new match value is written into the MATCH_L/H registers"]
    #[must_use]
    #[inline(always)]
    pub const fn ostimer_intrflag(&self) -> bool {
        let val = (self.0 >> 0usize) & 0x01;
        val != 0
    }
    #[doc = "This bit is set when a match occurs between the central 64-bit EVTIMER and the value programmed in the Match-register pair for the associated CPU This bit is cleared by writing a '1'. Writes to clear this bit are asynchronous. This should be done before a new match value is written into the MATCH_L/H registers"]
    #[inline(always)]
    pub const fn set_ostimer_intrflag(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
    }
    #[doc = "When this bit is '1' an interrupt/wakeup request to the Domainn processor will be asserted when the OSTIMER_INTR flag is set. When this bit is '0', interrupt/wakeup requests due to the OSTIMER_INTR flag are blocked.A separate OSEVENT_CTRL register is implemented for each CPU. Each CPU reads its own local value at the same address."]
    #[must_use]
    #[inline(always)]
    pub const fn ostimer_intena(&self) -> bool {
        let val = (self.0 >> 1usize) & 0x01;
        val != 0
    }
    #[doc = "When this bit is '1' an interrupt/wakeup request to the Domainn processor will be asserted when the OSTIMER_INTR flag is set. When this bit is '0', interrupt/wakeup requests due to the OSTIMER_INTR flag are blocked.A separate OSEVENT_CTRL register is implemented for each CPU. Each CPU reads its own local value at the same address."]
    #[inline(always)]
    pub const fn set_ostimer_intena(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
    }
    #[doc = "This bit will be low when it is safe to write to reload the Match Registers. In typical applications it should not be necessary to test this bit."]
    #[must_use]
    #[inline(always)]
    pub const fn match_wr_rdy(&self) -> bool {
        let val = (self.0 >> 2usize) & 0x01;
        val != 0
    }
    #[doc = "This bit will be low when it is safe to write to reload the Match Registers. In typical applications it should not be necessary to test this bit."]
    #[inline(always)]
    pub const fn set_match_wr_rdy(&mut self, val: bool) {
        self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
    }
}
impl Default for OseventCtrl {
    #[inline(always)]
    fn default() -> OseventCtrl {
        OseventCtrl(0)
    }
}
impl core::fmt::Debug for OseventCtrl {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("OseventCtrl")
            .field("ostimer_intrflag", &self.ostimer_intrflag())
            .field("ostimer_intena", &self.ostimer_intena())
            .field("match_wr_rdy", &self.match_wr_rdy())
            .finish()
    }
}
#[cfg(feature = "defmt")]
impl defmt::Format for OseventCtrl {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(
            f,
            "OseventCtrl {{ ostimer_intrflag: {=bool:?}, ostimer_intena: {=bool:?}, match_wr_rdy: {=bool:?} }}",
            self.ostimer_intrflag(),
            self.ostimer_intena(),
            self.match_wr_rdy()
        )
    }
}
